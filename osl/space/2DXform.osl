/*
 *  Copyright 2022 LAIKA. Modifications from Shader Writing in OSL by Mitch J Prater 2024.
 *
 *  Licensed under the Apache License Version 2.0 http://apache.org/licenses/LICENSE-2.0,
 *  or the MIT license http://opensource.org/licenses/MIT, at your option.
 *
 *  This program may not be copied, modified, or distributed except according to those terms.
 */
shader space_2DXform
[[
    int rfm_nodeid = 1306979,
    string rfm_classification = "rendernode/RenderMan/pattern/OSLBook"
]]
(
    string Notes = ""
    [[
        int connectable = 0,
        string help =
            "Transforms the 2D input space. "
    ]],

    point In = point(0)
    [[
        string help =
            "The 2D space to transform. "
    ]],

    int TransformCenter = 1
    [[
        int connectable = 0,
        string label = "Transform Center",
        string widget = "mapper",
        string options = "(0,0):0|(0.5,0.5):1",
        string help =
            "Do these transformations occur about the space's origin <i>(0,0)</i> "
            "or about a texture's center <i>(0.5,0.5)</i> ? "
    ]],

    float Size = 1.0
    [[
        string label = "Size",
        int slider = 1, float slidermin = 0.1, float slidermax = 10.0, float slidercenter = 1.0,
        string help =
            "Adjusts the output's size. "
    ]],

    float SizeMultiplier = 1.0
    [[
        string label = "Size Multiplier",
        string widget = "mapper",
        string options =
            "x0.01:0.01"
            "|x0.1:0.1"
            "|x1:1.0"
            "|x10:10.0"
            "|x100:100.0",
        string help =
            "Multiplies the <b>Size</b> by this constant, changing its effective range. "
    ]],

    float XSize = 1.0
    [[
        string label = "X (U) Size",
        int slider = 1, float slidermin = 0.1, float slidermax = 10.0, float slidercenter = 1.0,
        string help =
            "Adjusts the output's <b>Size</b> in the "
            "<b>X</b> (a.k.a. <i>s</i> or <i>U</i>) direction. "
    ]],

    float YSize = 1.0
    [[
        string label = "Y (V) Size",
        int slider = 1, float slidermin = 0.1, float slidermax = 10.0, float slidercenter = 1.0,
        string help =
            "Adjusts the output's <b>Size</b> in the "
            "<b>Y</b> (a.k.a. <i>t</i> or <i>V</i>) direction. "
    ]],

    float Rotation = 0.0
    [[
        string label = "Rotation",
        int slider = 1, float slidermin = -180.0, float slidermax = 180.0,
        string help =
            "Rotates <b>Y</b> (a.k.a. <i>t</i> or <i>V</i>) <i>into</i> "
            "<b>X</b> (a.k.a. <i>s</i> or <i>U</i>) by this many degrees. "
            "<p>"
            "Counterintuitively, this rotates a pattern generated by this space in the opposite direction. "
            "</p>"
    ]],

    float XOffset = 0.0
    [[
        string label = "X (U) Offset",
        int slider = 1, float slidermin = -5.0, float slidermax = 5.0,
        string help =
            "<b>Offset</b> the output "
            "in the <b>&ndash;X</b> (a.k.a. <i>s</i> or <i>U</i>) direction. "
            "<p>"
            "Counterintuitively, this moves a pattern generated by this space in the opposite direction. "
            "</p>"
    ]],

    float YOffset = 0.0
    [[
        string label = "Y (V) Offset",
        int slider = 1, float slidermin = -5.0, float slidermax = 5.0,
        string help =
            "<b>Offset</b> the output "
            "in the <b>&ndash;Y</b> (a.k.a. <i>t</i> or <i>V</i>) direction. "
            "<p>"
            "Counterintuitively, this moves a pattern generated by this space in the opposite direction. "
            "</p>"
    ]],

    output point Out = point(0.0),

    // Will read the 'st' primvar, or sets (s,t) = (u,v) if there is none.
    float  s = u [[ int connectable = 0, string widget = "null" ]],
    float  t = v [[ int connectable = 0, string widget = "null" ]]
)
{
    // The input space.
    if( isconnected( In ))
    {
        Out = In;
    }
    // Use st space: the Texture UV's.
    else
    {
        Out = point( s, t, 0 );
    }

    // Parameter values.
    float  size = Size * SizeMultiplier;
    float  xSize = max( 1.0e-6, size * XSize );
    float  ySize = max( 1.0e-6, size * YSize );
    float  rotation = radians( Rotation );

    // Transform Center.
    if( 1 == TransformCenter ) Out -= vector( 0.5, 0.5, 0.0 );

    // Size.
    Out /= point( xSize, ySize, 1.0 );

    // Rotate.
    float  sine, cosine;
    sincos( rotation, sine, cosine );

    Out = point(
            Out.x*cosine + Out.y*sine,
            Out.y*cosine - Out.x*sine,
            Out.z
            );

    // Transform Center.
    if( 1 == TransformCenter ) Out += vector( 0.5, 0.5, 0.0 );

    // Offset.
    Out -= vector( XOffset, YOffset, 0.0 );
}
